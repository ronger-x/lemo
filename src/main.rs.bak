use clap::{Parser, Subcommand};
use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use std::thread;
use std::time::Duration;
use sysinfo::{System, Disks, Networks, Components};
use winapi::um::shellapi::ShellExecuteW;
use winapi::um::winuser::SW_SHOWNORMAL;

#[derive(Parser)]
#[command(name = "lemo")]
#[command(author = "ronger")]
#[command(version = "0.1.0")]
#[command(about = "Windows ç³»ç»Ÿå·¥å…·é›†", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// ä¿®å¤ Windows å›¾æ ‡ç¼“å­˜
    FixIconCache {
        /// æ˜¯å¦è‡ªåŠ¨é‡å¯èµ„æºç®¡ç†å™¨
        #[arg(short, long, default_value_t = true)]
        restart_explorer: bool,
    },
    
    /// æ¸…ç†ç³»ç»Ÿä¸´æ—¶æ–‡ä»¶
    CleanTemp {
        /// æ˜¯å¦åŒ…å«ç”¨æˆ·ä¸´æ—¶æ–‡ä»¶å’Œæµè§ˆå™¨ç¼“å­˜
        #[arg(short, long)]
        include_user: bool,
    },
    
    /// æ˜¾ç¤ºç³»ç»Ÿä¿¡æ¯
    SysInfo,
}

// æ£€æŸ¥æ˜¯å¦ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ
fn is_admin() -> bool {
    use winapi::um::processthreadsapi::*;
    use winapi::um::securitybaseapi::*;
    use winapi::um::winnt::*;

    unsafe {
        let mut token_handle = std::ptr::null_mut();
        if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut token_handle) == 0 {
            return false;
        }

        let mut elevation = TOKEN_ELEVATION { TokenIsElevated: 0 };
        let mut return_length = 0;

        let result = GetTokenInformation(
            token_handle,
            TokenElevation,
            &mut elevation as *mut _ as *mut _,
            std::mem::size_of::<TOKEN_ELEVATION>() as u32,
            &mut return_length,
        );

        winapi::um::handleapi::CloseHandle(token_handle);

        result != 0 && elevation.TokenIsElevated != 0
    }
}

// ä»¥ç®¡ç†å‘˜èº«ä»½é‡æ–°è¿è¡Œç¨‹åº
fn run_as_admin() -> Result<(), Box<dyn std::error::Error>> {
    let exe_path = env::current_exe()?;
    let exe_path_str = exe_path.to_str().ok_or("æ— æ³•è·å–å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„")?;

    // è·å–å½“å‰å‘½ä»¤è¡Œå‚æ•°
    let args: Vec<String> = env::args().skip(1).collect();
    let params = args.join(" ");

    // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå®½å­—ç¬¦
    let operation: Vec<u16> = "runas\0".encode_utf16().collect();
    let file: Vec<u16> = format!("{}\0", exe_path_str).encode_utf16().collect();
    let parameters: Vec<u16> = format!("{}\0", params).encode_utf16().collect();

    unsafe {
        let result = ShellExecuteW(
            std::ptr::null_mut(),
            operation.as_ptr(),
            file.as_ptr(),
            parameters.as_ptr(),
            std::ptr::null(),
            SW_SHOWNORMAL,
        );

        if result as i32 <= 32 {
            return Err("æ— æ³•æå‡æƒé™".into());
        }
    }

    Ok(())
}

// ä¿®å¤å›¾æ ‡ç¼“å­˜
fn fix_icon_cache(restart_explorer: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”§ æ­£åœ¨ä¿®å¤å›¾æ ‡ç¼“å­˜...");

    // ç»“æŸ explorer.exe è¿›ç¨‹
    println!("â³ æ­£åœ¨å…³é—­èµ„æºç®¡ç†å™¨...");
    let _ = Command::new("taskkill")
        .args(&["/f", "/im", "explorer.exe"])
        .output();

    thread::sleep(Duration::from_secs(2));

    // è·å–ç”¨æˆ·ç›®å½•
    let user_profile = env::var("USERPROFILE")?;

    // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜æ–‡ä»¶
    let mut cache_files = Vec::new();

    // æ·»åŠ  IconCache.db
    let icon_cache = PathBuf::from(&user_profile).join(r"AppData\Local\IconCache.db");
    cache_files.push(icon_cache);

    // æ·»åŠ æ‰€æœ‰ iconcache_*.db æ–‡ä»¶
    let icon_cache_pattern =
        PathBuf::from(&user_profile).join(r"AppData\Local\Microsoft\Windows\Explorer");

    if let Ok(entries) = fs::read_dir(icon_cache_pattern) {
        for entry in entries.flatten() {
            let path = entry.path();
            if let Some(file_name) = path.file_name() {
                if let Some(name) = file_name.to_str() {
                    if name.starts_with("iconcache_") && name.ends_with(".db") {
                        cache_files.push(path);
                    }
                }
            }
        }
    }

    // åˆ é™¤ç¼“å­˜æ–‡ä»¶
    let mut deleted_count = 0;
    let mut skipped_count = 0;

    for file in cache_files {
        match fs::remove_file(&file) {
            Ok(_) => {
                println!("âœ… å·²åˆ é™¤: {:?}", file);
                deleted_count += 1;
            }
            Err(e) => {
                println!("âš ï¸  è·³è¿‡: {:?} ({})", file, e);
                skipped_count += 1;
            }
        }
    }

    println!(
        "\nğŸ“Š ç»Ÿè®¡: åˆ é™¤ {} ä¸ªæ–‡ä»¶, è·³è¿‡ {} ä¸ªæ–‡ä»¶",
        deleted_count, skipped_count
    );

    if restart_explorer {
        println!("ğŸ”„ æ­£åœ¨é‡å¯èµ„æºç®¡ç†å™¨...");
        Command::new("explorer.exe").spawn()?;
        println!("âœ¨ ä¿®å¤å®Œæˆï¼æ¡Œé¢å°†åœ¨å‡ ç§’å†…æ¢å¤ã€‚");
        thread::sleep(Duration::from_secs(3));
    } else {
        println!("âœ¨ ä¿®å¤å®Œæˆï¼è¯·æ‰‹åŠ¨å¯åŠ¨èµ„æºç®¡ç†å™¨ã€‚");
    }

    Ok(())
}

// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
fn clean_temp(include_user: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ§¹ æ­£åœ¨æ¸…ç†ä¸´æ—¶æ–‡ä»¶...");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let mut total_deleted = 0;
    let mut total_failed = 0;
    let mut total_size_freed: u64 = 0;

    // æ¸…ç† Windows ä¸´æ—¶æ–‡ä»¶ç›®å½•
    let windows_temp = PathBuf::from(r"C:\Windows\Temp");
    if windows_temp.exists() {
        println!("\nğŸ“ æ¸…ç† Windows ä¸´æ—¶ç›®å½•: {}", windows_temp.display());
        let (deleted, failed, size) = clean_directory(&windows_temp)?;
        total_deleted += deleted;
        total_failed += failed;
        total_size_freed += size;
        println!("   åˆ é™¤: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹, è·³è¿‡: {} ä¸ª, é‡Šæ”¾ç©ºé—´: {:.2} MB", 
                 deleted, failed, size as f64 / 1024.0 / 1024.0);
    }

    // æ¸…ç†ç”¨æˆ·ä¸´æ—¶æ–‡ä»¶ç›®å½•
    if include_user {
        if let Ok(temp) = env::var("TEMP") {
            let user_temp = PathBuf::from(temp);
            if user_temp.exists() {
                println!("\nğŸ“ æ¸…ç†ç”¨æˆ·ä¸´æ—¶ç›®å½•: {}", user_temp.display());
                let (deleted, failed, size) = clean_directory(&user_temp)?;
                total_deleted += deleted;
                total_failed += failed;
                total_size_freed += size;
                println!("   åˆ é™¤: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹, è·³è¿‡: {} ä¸ª, é‡Šæ”¾ç©ºé—´: {:.2} MB", 
                         deleted, failed, size as f64 / 1024.0 / 1024.0);
            }
        }

        // æ¸…ç†æµè§ˆå™¨ç¼“å­˜
        if let Ok(localappdata) = env::var("LOCALAPPDATA") {
            // Chrome ç¼“å­˜
            let chrome_cache = PathBuf::from(&localappdata)
                .join(r"Google\Chrome\User Data\Default\Cache");
            if chrome_cache.exists() {
                println!("\nğŸ“ æ¸…ç† Chrome ç¼“å­˜: {}", chrome_cache.display());
                let (deleted, failed, size) = clean_directory(&chrome_cache)?;
                total_deleted += deleted;
                total_failed += failed;
                total_size_freed += size;
                println!("   åˆ é™¤: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹, è·³è¿‡: {} ä¸ª, é‡Šæ”¾ç©ºé—´: {:.2} MB", 
                         deleted, failed, size as f64 / 1024.0 / 1024.0);
            }

            // Edge ç¼“å­˜
            let edge_cache = PathBuf::from(&localappdata)
                .join(r"Microsoft\Edge\User Data\Default\Cache");
            if edge_cache.exists() {
                println!("\nğŸ“ æ¸…ç† Edge ç¼“å­˜: {}", edge_cache.display());
                let (deleted, failed, size) = clean_directory(&edge_cache)?;
                total_deleted += deleted;
                total_failed += failed;
                total_size_freed += size;
                println!("   åˆ é™¤: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹, è·³è¿‡: {} ä¸ª, é‡Šæ”¾ç©ºé—´: {:.2} MB", 
                         deleted, failed, size as f64 / 1024.0 / 1024.0);
            }
        }

        // æ¸…ç†å›æ”¶ç«™ï¼ˆä»…ç»Ÿè®¡ï¼Œä¸åˆ é™¤ï¼‰
        println!("\nğŸ“ æ£€æŸ¥å›æ”¶ç«™...");
        if let Ok(userprofile) = env::var("USERPROFILE") {
            let recycle_bin = PathBuf::from(userprofile).join(r"$Recycle.Bin");
            if recycle_bin.exists() {
                let size = calculate_dir_size(&recycle_bin);
                println!("   å›æ”¶ç«™å¤§å°: {:.2} MB (ä½¿ç”¨'æ¸…ç©ºå›æ”¶ç«™'åŠŸèƒ½æ¥æ¸…ç†)", 
                         size as f64 / 1024.0 / 1024.0);
            }
        }
    }

    println!("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("ğŸ“Š æ¸…ç†ç»Ÿè®¡:");
    println!("   æ€»åˆ é™¤: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹", total_deleted);
    println!("   æ€»è·³è¿‡: {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹", total_failed);
    println!("   é‡Šæ”¾ç©ºé—´: {:.2} MB ({:.2} GB)", 
             total_size_freed as f64 / 1024.0 / 1024.0,
             total_size_freed as f64 / 1024.0 / 1024.0 / 1024.0);
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ¨ æ¸…ç†å®Œæˆï¼");

    Ok(())
}

// æ¸…ç†ç›®å½•ä¸­çš„æ–‡ä»¶
fn clean_directory(dir: &PathBuf) -> Result<(usize, usize, u64), Box<dyn std::error::Error>> {
    let mut deleted_count = 0;
    let mut failed_count = 0;
    let mut total_size = 0u64;

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            
            // è·å–æ–‡ä»¶å¤§å°
            let size = if path.is_file() {
                fs::metadata(&path).map(|m| m.len()).unwrap_or(0)
            } else if path.is_dir() {
                calculate_dir_size(&path)
            } else {
                0
            };

            // å°è¯•åˆ é™¤
            let result = if path.is_dir() {
                fs::remove_dir_all(&path)
            } else {
                fs::remove_file(&path)
            };

            match result {
                Ok(_) => {
                    deleted_count += 1;
                    total_size += size;
                    if deleted_count <= 5 {  // åªæ˜¾ç¤ºå‰5ä¸ªåˆ é™¤çš„æ–‡ä»¶
                        println!("   âœ… åˆ é™¤: {}", path.file_name().unwrap_or_default().to_string_lossy());
                    }
                }
                Err(_) => {
                    failed_count += 1;
                    if failed_count <= 3 {  // åªæ˜¾ç¤ºå‰3ä¸ªå¤±è´¥çš„æ–‡ä»¶
                        println!("   âš ï¸  è·³è¿‡: {} (æ–‡ä»¶è¢«å ç”¨æˆ–æƒé™ä¸è¶³)", 
                                 path.file_name().unwrap_or_default().to_string_lossy());
                    }
                }
            }
        }

        if deleted_count > 5 {
            println!("   ... è¿˜æœ‰ {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹å·²åˆ é™¤", deleted_count - 5);
        }
        if failed_count > 3 {
            println!("   ... è¿˜æœ‰ {} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹è¢«è·³è¿‡", failed_count - 3);
        }
    }

    Ok((deleted_count, failed_count, total_size))
}

// è®¡ç®—ç›®å½•å¤§å°
fn calculate_dir_size(dir: &PathBuf) -> u64 {
    let mut size = 0u64;
    
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() {
                size += fs::metadata(&path).map(|m| m.len()).unwrap_or(0);
            } else if path.is_dir() {
                size += calculate_dir_size(&path);
            }
        }
    }
    
    size
}

// æ˜¾ç¤ºç³»ç»Ÿä¿¡æ¯ï¼ˆç¤ºä¾‹åŠŸèƒ½ï¼‰
fn show_sys_info() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ’» ç³»ç»Ÿä¿¡æ¯:");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // åŸºæœ¬ç³»ç»Ÿä¿¡æ¯
    println!("\nğŸ“Œ åŸºæœ¬ä¿¡æ¯:");
    println!("  æ“ä½œç³»ç»Ÿ: {}", env::consts::OS);
    println!("  ç³»ç»Ÿæ¶æ„: {}", env::consts::ARCH);
    println!("  ç”¨æˆ·å: {}", env::var("USERNAME").unwrap_or_else(|_| "æœªçŸ¥".to_string()));
    println!("  è®¡ç®—æœºå: {}", env::var("COMPUTERNAME").unwrap_or_else(|_| "æœªçŸ¥".to_string()));
    
    // åˆå§‹åŒ–ç³»ç»Ÿä¿¡æ¯
    let mut sys = System::new_all();
    sys.refresh_all();
    
    // CPU ä¿¡æ¯
    println!("\nğŸ”§ CPU ä¿¡æ¯:");
    println!("  CPU æ ¸å¿ƒæ•°: {} ä¸ªç‰©ç†æ ¸å¿ƒ", sys.physical_core_count().unwrap_or(0));
    println!("  CPU é€»è¾‘æ ¸å¿ƒæ•°: {} ä¸ª", sys.cpus().len());
    
    if let Some(cpu) = sys.cpus().first() {
        println!("  CPU å‹å·: {}", cpu.brand());
        println!("  CPU é¢‘ç‡: {} MHz", cpu.frequency());
    }
    
    // æ€»ä½“ CPU ä½¿ç”¨ç‡
    thread::sleep(Duration::from_millis(500));
    sys.refresh_cpu_usage();
    let total_usage: f32 = sys.cpus().iter().map(|cpu| cpu.cpu_usage()).sum::<f32>() / sys.cpus().len() as f32;
    println!("  CPU æ€»ä½¿ç”¨ç‡: {:.2}%", total_usage);
    
    // å†…å­˜ä¿¡æ¯
    println!("\nğŸ’¾ å†…å­˜ä¿¡æ¯:");
    let total_mem = sys.total_memory() as f64 / 1024.0 / 1024.0 / 1024.0;
    let used_mem = sys.used_memory() as f64 / 1024.0 / 1024.0 / 1024.0;
    let available_mem = sys.available_memory() as f64 / 1024.0 / 1024.0 / 1024.0;
    println!("  æ€»å†…å­˜: {:.2} GB", total_mem);
    println!("  å·²ä½¿ç”¨: {:.2} GB ({:.1}%)", used_mem, (used_mem / total_mem) * 100.0);
    println!("  å¯ç”¨å†…å­˜: {:.2} GB", available_mem);
    
    let total_swap = sys.total_swap() as f64 / 1024.0 / 1024.0 / 1024.0;
    let used_swap = sys.used_swap() as f64 / 1024.0 / 1024.0 / 1024.0;
    if total_swap > 0.0 {
        println!("  äº¤æ¢ç©ºé—´: {:.2} GB (å·²ä½¿ç”¨ {:.2} GB)", total_swap, used_swap);
    }
    
    // ç¡¬ç›˜ä¿¡æ¯
    println!("\nğŸ’¿ ç£ç›˜ä¿¡æ¯:");
    let disks = Disks::new_with_refreshed_list();
    for disk in &disks {
        let total_space = disk.total_space() as f64 / 1024.0 / 1024.0 / 1024.0;
        let available_space = disk.available_space() as f64 / 1024.0 / 1024.0 / 1024.0;
        let used_space = total_space - available_space;
        let usage_percent = (used_space / total_space) * 100.0;
        
        println!("  {} - {}", 
            disk.name().to_string_lossy(),
            disk.mount_point().display()
        );
        println!("    æ–‡ä»¶ç³»ç»Ÿ: {:?}", disk.file_system());
        println!("    æ€»å®¹é‡: {:.2} GB", total_space);
        println!("    å·²ä½¿ç”¨: {:.2} GB ({:.1}%)", used_space, usage_percent);
        println!("    å¯ç”¨ç©ºé—´: {:.2} GB", available_space);
    }
    
    // æ¸©åº¦ä¿¡æ¯
    println!("\nğŸŒ¡ï¸  æ¸©åº¦ä¿¡æ¯:");
    let components = Components::new_with_refreshed_list();
    if components.is_empty() {
        println!("  âš ï¸  æ— æ³•è·å–æ¸©åº¦ä¿¡æ¯ï¼ˆå¯èƒ½éœ€è¦ç®¡ç†å‘˜æƒé™æˆ–ç¡¬ä»¶ä¸æ”¯æŒï¼‰");
    } else {
        for component in &components {
            println!("  {}: {:.1}Â°C", component.label(), component.temperature());
            if let Some(critical) = component.critical() {
                println!("    (ä¸´ç•Œæ¸©åº¦: {:.1}Â°C)", critical);
            }
        }
    }
    
    // ç½‘ç»œä¿¡æ¯
    println!("\nğŸŒ ç½‘ç»œæ¥å£:");
    let networks = Networks::new_with_refreshed_list();
    for (interface_name, data) in &networks {
        println!("  {}", interface_name);
        println!("    æ¥æ”¶: {:.2} MB", data.total_received() as f64 / 1024.0 / 1024.0);
        println!("    å‘é€: {:.2} MB", data.total_transmitted() as f64 / 1024.0 / 1024.0);
    }
    
    // ç³»ç»Ÿè¿è¡Œæ—¶é—´
    println!("\nâ±ï¸  ç³»ç»Ÿè¿è¡Œæ—¶é—´:");
    let uptime = System::uptime();
    let days = uptime / 86400;
    let hours = (uptime % 86400) / 3600;
    let minutes = (uptime % 3600) / 60;
    println!("  {} å¤© {} å°æ—¶ {} åˆ†é’Ÿ", days, hours, minutes);
    
    println!("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    Ok(())
}

fn main() {
    let cli = Cli::parse();

    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç®¡ç†å‘˜æƒé™
    let needs_admin = matches!(cli.command, Commands::FixIconCache { .. } | Commands::CleanTemp { .. });

    if needs_admin && !is_admin() {
        println!("âš ï¸  éœ€è¦ç®¡ç†å‘˜æƒé™ï¼Œæ­£åœ¨å°è¯•ææƒ...");
        match run_as_admin() {
            Ok(_) => {
                println!("âœ… å·²è¯·æ±‚ææƒï¼Œè¯·åœ¨ UAC å¯¹è¯æ¡†ä¸­å…è®¸...");
                std::process::exit(0);
            }
            Err(e) => {
                eprintln!("âŒ ææƒå¤±è´¥: {}", e);
                std::process::exit(1);
            }
        }
    }

    // æ‰§è¡Œå¯¹åº”çš„å‘½ä»¤
    let result = match cli.command {
        Commands::FixIconCache { restart_explorer } => fix_icon_cache(restart_explorer),
        Commands::CleanTemp { include_user } => clean_temp(include_user),
        Commands::SysInfo => show_sys_info(),
    };

    match result {
        Ok(_) => {
            if needs_admin {
                println!("\nâœ… æ“ä½œå®Œæˆï¼æŒ‰å›è½¦é”®é€€å‡º...");
                let mut input = String::new();
                let _ = std::io::stdin().read_line(&mut input);
            }
        }
        Err(e) => {
            eprintln!("âŒ å‘ç”Ÿé”™è¯¯: {}", e);
            println!("\næŒ‰å›è½¦é”®é€€å‡º...");
            let mut input = String::new();
            let _ = std::io::stdin().read_line(&mut input);
            std::process::exit(1);
        }
    }
}